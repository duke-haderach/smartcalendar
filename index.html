<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Wall Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- Google APIs -->
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://accounts.google.com/gsi/client"></script>
<!-- TradingView Widget (custom to reduce size) -->
<script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  width: 100%;
  font-family: Arial, sans-serif;
  color: #ffffff;
  overflow: hidden;
}
body {
  background-image: url("background.jpg");
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
.overlay {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at top, rgba(0,0,0,0.35), rgba(0,0,0,0.85));
  display: flex;
  flex-direction: row;
  padding: 16px;
  box-sizing: border-box;
}
.left-panel {
  flex: 2;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.right-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 16px;
  margin-left: 16px;
  min-height: 0;
}
#weather-panel {
  flex: 3 1 0;
  min-height: 180px;
  max-height: 1060px;
  overflow-y: auto;
}
#stock-panel {
  flex: 2 1 0;
  min-height: 140px;
}
.panel {
  background: rgba(0, 0, 0, 0.45);
  border-radius: 8px;
  padding: 12px 16px;
  box-sizing: border-box;
}
/* ===== CLOCK WIDGET ===== */
#clock-container {
  display: flex;
  align-items: center;
  gap: 20px;
}
#clock-widget {
  display: flex;
  flex-direction: column;
}
#clock {
  font-size: 42px; /* Larger for emphasis */
  font-weight: 700;
  letter-spacing: 1px;
}
#date {
  font-size: 18px;
  opacity: 0.9;
  margin-top: 4px;
}
/* Analog Clock */
#analog-clock {
  width: 100px;
  height: 100px;
  position: relative;
}
.clock-face {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.1);
  position: relative;
  border: 3px solid rgba(255, 255, 255, 0.3);
}
.clock-center {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #ffffff;
  border-radius: 50%;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
}
.hour-hand, .minute-hand, .second-hand {
  position: absolute;
  transform-origin: bottom center;
  left: 50%;
  bottom: 50%;
}
.hour-hand {
  width: 4px;
  height: 30px;
  background: #ffffff;
  margin-left: -2px;
  border-radius: 2px;
}
.minute-hand {
  width: 3px;
  height: 40px;
  background: #ffffff;
  margin-left: -1.5px;
  border-radius: 1.5px;
}
.second-hand {
  width: 2px;
  height: 45px;
  background: #ff4444;
  margin-left: -1px;
  border-radius: 1px;
}
.clock-mark {
  position: absolute;
  background: rgba(255, 255, 255, 0.6);
}
.mark-hour {
  width: 3px;
  height: 8px;
}
.mark-minute {
  width: 2px;
  height: 4px;
}
#events-container {
  max-height: 800px;
  overflow-y: auto;
}
#events {
  flex: 1;
  overflow-y: auto;
  font-size: 16px;
  max-height: 100%;
}
.event-day {
  margin-top: 10px;
  font-weight: 600;
  font-size: 15px;
  opacity: 0.9;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}
/* ===== FIXED EVENT LAYOUT ===== */
.event-item {
  margin-top: 6px;
  padding: 6px 8px;
  background: rgba(0, 255, 0, 0.05);
  border-radius: 6px;
  color: #f7f5f5;
  font-size: 15px;
  font-weight: bold;
  display: flex;
  flex-direction: column;
}
.event-time-container {
  display: flex;
  align-items: flex-start;
  margin-bottom: 4px;
}
.event-time {
  font-weight: 600;
  min-width: 140px; /* Fixed width for time column */
  white-space: nowrap;
  padding-right: 10px;
}
.event-title {
  flex: 1;
  line-height: 1.4;
}
/* Second line for end time and location */
.event-details {
  display: flex;
  margin-left: 140px; /* Aligns with event title start */
  font-size: 13px;
  color: #e3dede;
  gap: 20px;
}
.event-end-time {
  font-weight: 500;
  white-space: nowrap;
}
.event-location {
  flex: 1;
}
/* ===== WEATHER ===== */
#weather-current {
  font-size: 22px;
  font-weight: 600;
}
#weather-forecast {
  margin-top: 8px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  font-size: 14px;
}
.weather-day {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 6px;
  background: rgba(255,255,255,0.07);
  border-radius: 4px;
}
.weather-icon {
  width: 38px;
  height: 38px;
  margin-right: 8px;
}
.weather-name {
  width: 80px;
  font-weight: 600;
}
.weather-temp {
  font-weight: 600;
  margin-right: 10px;
  margin-left: 15px;
}
.weather-desc {
  opacity: 0.9;
  flex: 1;
  text-align: right;
  margin-left: 15px;
}
/* ===== BUTTONS ===== */
#enable-voice {
  padding: 6px 10px;
  margin-top: 6px;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #ffffff;
  background: rgba(255,255,255,0.1);
  color: #ffffff;
  cursor: pointer;
  display: inline-block;
}
#enable-voice:hover {
  background: rgba(255,255,255,0.25);
}
#sign-in {
  padding: 8px 16px;
  margin-top: 6px;
  font-size: 14px;
  border-radius: 4px;
  border: 1px solid #ffffff;
  background: rgba(255,255,255,0.1);
  color: #ffffff;
  cursor: pointer;
  display: inline-block;
}
#sign-in:hover {
  background: rgba(255,255,255,0.25);
}
</style>
</head>
<body>
<div class="overlay">
  <div class="left-panel">
    <!-- Clock Panel with Analog Clock -->
    <div class="panel">
      <div id="clock-container">
        <div id="clock-widget">
          <div id="clock">--:-- --</div>
          <div id="date">Loading date…</div>
        </div>
        <div id="analog-clock">
          <div class="clock-face">
            <div class="clock-center"></div>
            <div class="hour-hand"></div>
            <div class="minute-hand"></div>
            <div class="second-hand"></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Events Panel -->
    <div class="panel" id="events-panel">
      <div style="font-size:18px;font-weight:600;margin-bottom:6px;">
        Upcoming Events
      </div>
      <div id="auth-status">Initializing...</div>
      <button id="sign-in" disabled>Loading Google Sign-in...</button>
      <button id="enable-voice">Enable voice alerts</button>
      <div id="events-container">
        <div id="events"></div>
      </div>
    </div>
  </div>
  
  <!-- Right Panel -->
  <div class="right-panel">
    <div class="panel" id="weather-panel">
      <div id="weather-current">Loading weather…</div>
      <div id="weather-forecast"></div>
    </div>
    <div class="panel" id="stock-panel">
      <!-- Custom TradingView Widget with reduced size -->
      <div id="tradingview-widget"></div>
    </div>
  </div>
</div>

<script>
// ===== CONFIGURATION =====
const CLIENT_ID = "703875968822-6ma5u7st5qm3eqgb1ktt9p52vs8knrb3.apps.googleusercontent.com";
const API_KEY = "AIzaSyCcx8q0nHP9DkA-M_KFyjFo-uLV-7TOrSE";
const SCOPES = "https://www.googleapis.com/auth/calendar.readonly";
const CALENDAR_ID = "family03331431524389313579@group.calendar.google.com";

// ===== GLOBAL VARIABLES =====
let tokenClient = null;
let calendarRefreshInterval = null;
let reminderCheckInterval = null;
let spokenEvents = new Set();
let voiceEnabled = false;
let voiceEnabledDate = null;

// ===== CLOCK FUNCTIONS =====
function updateClock() {
  const now = new Date();
  
  // Digital clock with AM/PM
  const timeString = now.toLocaleTimeString([], {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  });
  document.getElementById("clock").textContent = timeString;
  
  // Date
  document.getElementById("date").textContent = now.toLocaleDateString(undefined, {
    weekday: "long",
    month: "long",
    day: "numeric",
  });
  
  // Update analog clock
  updateAnalogClock(now);
}

function updateAnalogClock(now) {
  const hours = now.getHours() % 12;
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  
  // Calculate angles
  const hourAngle = (hours * 30) + (minutes * 0.5); // 30 degrees per hour, 0.5 per minute
  const minuteAngle = (minutes * 6) + (seconds * 0.1); // 6 degrees per minute, 0.1 per second
  const secondAngle = seconds * 6; // 6 degrees per second
  
  // Update hands
  document.querySelector('.hour-hand').style.transform = `translateX(-50%) rotate(${hourAngle}deg)`;
  document.querySelector('.minute-hand').style.transform = `translateX(-50%) rotate(${minuteAngle}deg)`;
  document.querySelector('.second-hand').style.transform = `translateX(-50%) rotate(${secondAngle}deg)`;
}

function createClockMarks() {
  const clockFace = document.querySelector('.clock-face');
  
  // Create hour marks (12)
  for (let i = 0; i < 12; i++) {
    const mark = document.createElement('div');
    mark.className = 'clock-mark mark-hour';
    
    const angle = i * 30; // 30 degrees each
    const radius = 45; // Position from center
    const x = 50 + radius * Math.sin(angle * Math.PI / 180);
    const y = 50 - radius * Math.cos(angle * Math.PI / 180);
    
    mark.style.left = `${x}%`;
    mark.style.top = `${y}%`;
    mark.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
    
    clockFace.appendChild(mark);
  }
}

// Initialize clock
createClockMarks();
setInterval(updateClock, 1000);
updateClock();

// ===== GOOGLE AUTH =====
function initGoogleApi() {
  console.log("Initializing Google API...");
  
  if (!window.gapi) {
    console.error("Google API library not loaded");
    document.getElementById("auth-status").textContent = "Error: Google API failed to load";
    return;
  }
  
  gapi.load('client', async () => {
    try {
      await gapi.client.init({
        apiKey: API_KEY,
        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest'],
      });
      console.log("Google API client initialized");
      initGoogleIdentity();
    } catch (error) {
      console.error("Failed to initialize Google API:", error);
      document.getElementById("auth-status").textContent = "Error initializing Google API";
    }
  });
}

function initGoogleIdentity() {
  console.log("Initializing Google Identity Services...");
  
  if (!window.google || !window.google.accounts) {
    console.error("Google Identity Services not loaded");
    document.getElementById("auth-status").textContent = "Error: Google Sign-in failed to load";
    return;
  }
  
  try {
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPES,
      callback: (tokenResponse) => {
        console.log("Authentication callback");
        
        if (tokenResponse && tokenResponse.access_token) {
          gapi.client.setToken(tokenResponse);
          updateAuthUI(true);
          loadCalendarEvents();
          startAutoRefresh();
        } else {
          console.log("Authentication cancelled or failed");
          document.getElementById("auth-status").textContent = "Sign-in cancelled";
        }
      },
      error_callback: (error) => {
        console.error("Authentication error:", error);
        document.getElementById("auth-status").textContent = "Sign-in error occurred";
      }
    });
    
    console.log("Google Identity Services initialized");
    setupAuthButton();
    
  } catch (error) {
    console.error("Failed to initialize Google Identity:", error);
    document.getElementById("auth-status").textContent = "Error setting up Google Sign-in";
  }
}

function setupAuthButton() {
  const signInBtn = document.getElementById("sign-in");
  const token = gapi.client.getToken();
  
  if (token && token.access_token) {
    signInBtn.textContent = "Sign out";
    signInBtn.disabled = false;
    document.getElementById("auth-status").textContent = "Already signed in";
    loadCalendarEvents();
    startAutoRefresh();
  } else {
    signInBtn.textContent = "Sign in with Google";
    signInBtn.disabled = false;
    document.getElementById("auth-status").textContent = "Ready to sign in";
  }
  
  signInBtn.onclick = handleAuthClick;
}

function handleAuthClick() {
  const token = gapi.client.getToken();
  
  if (token && token.access_token) {
    handleSignOut();
  } else {
    handleSignIn();
  }
}

function handleSignIn() {
  console.log("Starting sign in...");
  
  if (!tokenClient) {
    document.getElementById("auth-status").textContent = "Sign-in not ready. Please refresh.";
    return;
  }
  
  document.getElementById("auth-status").textContent = "Opening Google sign-in...";
  tokenClient.requestAccessToken();
}

function handleSignOut() {
  console.log("Signing out...");
  
  const token = gapi.client.getToken();
  if (token) {
    google.accounts.oauth2.revoke(token.access_token, () => {
      console.log("Access token revoked");
    });
  }
  
  gapi.client.setToken(null);
  stopAutoRefresh();
  stopVoiceReminders();
  
  localStorage.removeItem('calendarEvents');
  localStorage.removeItem('eventsLastUpdated');
  localStorage.removeItem('voiceEnabledDate');
  
  document.getElementById("events").innerHTML = "";
  document.getElementById("sign-in").textContent = "Sign in with Google";
  document.getElementById("auth-status").textContent = "Signed out. Click to sign in again.";
  document.getElementById("enable-voice").style.display = "inline-block";
  document.getElementById("enable-voice").textContent = "Enable voice alerts";
  
  spokenEvents.clear();
  voiceEnabled = false;
  voiceEnabledDate = null;
}

function updateAuthUI(isSignedIn) {
  const signInBtn = document.getElementById("sign-in");
  signInBtn.textContent = isSignedIn ? "Sign out" : "Sign in with Google";
  document.getElementById("auth-status").textContent = isSignedIn ? "Signed in successfully!" : "Ready to sign in";
}

// ===== CALENDAR EVENTS =====
async function loadCalendarEvents() {
  console.log("Loading calendar events...");
  
  try {
    const now = new Date();
    const timeMin = now.toISOString();
    const timeMax = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString();

    const response = await gapi.client.calendar.events.list({
      calendarId: CALENDAR_ID,
      timeMin,
      timeMax,
      showDeleted: false,
      singleEvents: true,
      orderBy: "startTime",
      maxResults: 100,
    });
    
    const events = response.result.items || [];
    console.log(`Loaded ${events.length} events`);
    
    if (events.length === 0) {
      document.getElementById("events").textContent = "No upcoming events found.";
      return;
    }
    
    renderEvents(events);
    
    localStorage.setItem('calendarEvents', JSON.stringify(events));
    localStorage.setItem('eventsLastUpdated', Date.now());
    
    checkVoiceEnabledForToday();
    
    if (voiceEnabled) {
      scheduleVoiceReminders(events);
    }
    
  } catch (error) {
    console.error("Error loading calendar:", error);
    document.getElementById("auth-status").textContent = "Error loading calendar";
    
    if (error.status === 401) {
      handleSignOut();
    }
  }
}

function renderEvents(events) {
  const container = document.getElementById("events");
  container.innerHTML = "";

  const eventsByDate = {};
  
  events.forEach(event => {
    const start = event.start.dateTime || event.start.date;
    const date = new Date(start);
    const dateKey = date.toDateString();
    
    if (!eventsByDate[dateKey]) {
      eventsByDate[dateKey] = [];
    }
    
    eventsByDate[dateKey].push(event);
  });

  Object.keys(eventsByDate)
    .sort((a, b) => new Date(a) - new Date(b))
    .forEach(dateKey => {
      const dayHeader = document.createElement("div");
      dayHeader.className = "event-day";
      dayHeader.textContent = dateKey;
      container.appendChild(dayHeader);

      eventsByDate[dateKey]
        .sort((a, b) => new Date(a.start.dateTime || a.start.date) - new Date(b.start.dateTime || b.start.date))
        .forEach(event => {
          const eventItem = document.createElement("div");
          eventItem.className = "event-item";

          // Parse times
          const isAllDay = !!event.start.date;
          const startTime = event.start.dateTime ? new Date(event.start.dateTime) : null;
          const endTime = event.end.dateTime ? new Date(event.end.dateTime) : null;
          
          // Create time container (first line)
          const timeContainer = document.createElement("div");
          timeContainer.className = "event-time-container";
          
          const timeSpan = document.createElement("div");
          timeSpan.className = "event-time";
          
          if (isAllDay) {
            timeSpan.textContent = "All day";
          } else if (startTime) {
            timeSpan.textContent = startTime.toLocaleTimeString([], {
              hour: "numeric",
              minute: "2-digit",
              hour12: true,
            });
          }
          
          const titleSpan = document.createElement("div");
          titleSpan.className = "event-title";
          titleSpan.textContent = event.summary || "(No title)";
          
          timeContainer.appendChild(timeSpan);
          timeContainer.appendChild(titleSpan);
          eventItem.appendChild(timeContainer);
          
          // Create details container (second line)
          if (!isAllDay || event.location) {
            const detailsContainer = document.createElement("div");
            detailsContainer.className = "event-details";
            
            // Add end time if available
            if (endTime && !isAllDay) {
              const endTimeSpan = document.createElement("div");
              endTimeSpan.className = "event-end-time";
              endTimeSpan.textContent = `to ${endTime.toLocaleTimeString([], {
                hour: "numeric",
                minute: "2-digit",
                hour12: true,
              })}`;
              detailsContainer.appendChild(endTimeSpan);
            }
            
            // Add location if available
            if (event.location) {
              const locationDiv = document.createElement("div");
              locationDiv.className = "event-location";
              locationDiv.textContent = event.location;
              detailsContainer.appendChild(locationDiv);
            }
            
            eventItem.appendChild(detailsContainer);
          }
          
          container.appendChild(eventItem);
        });
    });
}

// ===== AUTO REFRESH =====
function startAutoRefresh() {
  console.log("Starting auto-refresh (every 5 minutes)");
  
  if (calendarRefreshInterval) {
    clearInterval(calendarRefreshInterval);
  }
  
  loadCalendarEvents();
  calendarRefreshInterval = setInterval(loadCalendarEvents, 5 * 60 * 1000);
}

function stopAutoRefresh() {
  if (calendarRefreshInterval) {
    clearInterval(calendarRefreshInterval);
    calendarRefreshInterval = null;
    console.log("Stopped auto-refresh");
  }
}

// ===== VOICE REMINDERS =====
function checkVoiceEnabledForToday() {
  const savedDate = localStorage.getItem('voiceEnabledDate');
  const today = new Date().toDateString();
  
  if (savedDate === today) {
    voiceEnabled = true;
    voiceEnabledDate = today;
    document.getElementById("enable-voice").style.display = "none";
    console.log("Voice alerts already enabled for today");
  } else {
    voiceEnabled = false;
    voiceEnabledDate = null;
    document.getElementById("enable-voice").style.display = "inline-block";
    document.getElementById("enable-voice").textContent = "Enable voice alerts";
  }
}

function scheduleVoiceReminders(events) {
  console.log("Scheduling voice reminders for", events.length, "events");
  
  if (!("speechSynthesis" in window)) {
    alert("Your browser doesn't support voice synthesis");
    return;
  }
  
  const today = new Date().toDateString();
  localStorage.setItem('voiceEnabledDate', today);
  voiceEnabled = true;
  voiceEnabledDate = today;
  
  document.getElementById("enable-voice").style.display = "none";
  
  if (reminderCheckInterval) {
    clearInterval(reminderCheckInterval);
    spokenEvents.clear();
  }
  
  reminderCheckInterval = setInterval(() => checkReminders(events), 10000);
  checkReminders(events);
}

function checkReminders(events) {
  const now = new Date();
  const nowMs = now.getTime();
  
  events.forEach(event => {
    if (!event.start || !event.start.dateTime) return;
    
    const eventStart = new Date(event.start.dateTime);
    const eventStartMs = eventStart.getTime();
    const eventId = event.id || event.summary;
    const minutesUntilEvent = (eventStartMs - nowMs) / (60 * 1000);
    
    if (minutesUntilEvent <= 30 && minutesUntilEvent > 29.5) {
      const reminderKey = `${eventId}_30min`;
      if (!spokenEvents.has(reminderKey)) {
        console.log(`Triggering 30-min reminder for: ${event.summary}`);
        speakReminder(event, 30);
        spokenEvents.add(reminderKey);
      }
    }
    
    if (minutesUntilEvent <= 15 && minutesUntilEvent > 14.5) {
      const reminderKey = `${eventId}_15min`;
      if (!spokenEvents.has(reminderKey)) {
        console.log(`Triggering 15-min reminder for: ${event.summary}`);
        speakReminder(event, 15);
        spokenEvents.add(reminderKey);
      }
    }
  });
}

function speakReminder(event, minutesBefore) {
  console.log(`Speaking ${minutesBefore}-min reminder:`, event.summary);
  const message = `Reminder: "${event.summary || "Event"}" starts in ${minutesBefore} minutes.`;
  const utterance = new SpeechSynthesisUtterance(message);
  utterance.rate = 1.0;
  utterance.pitch = 1.0;
  utterance.volume = 1.0;
  
  window.speechSynthesis.cancel();
  setTimeout(() => {
    window.speechSynthesis.speak(utterance);
  }, 50);
}

function stopVoiceReminders() {
  if (reminderCheckInterval) {
    clearInterval(reminderCheckInterval);
    reminderCheckInterval = null;
    spokenEvents.clear();
    console.log("Stopped voice reminders");
  }
}

// ===== WEATHER =====
const LAT = 38.81;
const LON = -90.72;

function loadWeather() {
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&daily=temperature_2m_max,temperature_2m_min,weathercode&temperature_unit=fahrenheit&current_weather=true&timezone=auto`;

  fetch(url)
    .then(response => response.json())
    .then(data => renderWeather(data))
    .catch(error => {
      document.getElementById("weather-current").textContent = "Weather error";
      console.error("Weather error:", error);
    });
}

function renderWeather(data) {
  const current = data.current_weather;
  const daily = data.daily;

  document.getElementById("weather-current").textContent = 
    `${Math.round(current.temperature)}° ${getWeatherDescription(current.weathercode)}`;

  const forecastEl = document.getElementById("weather-forecast");
  forecastEl.innerHTML = "";

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  let displayed = 0;

  for (let i = 0; i < daily.time.length && displayed < 7; i++) {
    const date = new Date(daily.time[i]);
    const localDate = new Date(date);
    localDate.setHours(0, 0, 0, 0);
    
    if (localDate < today) continue;

    const row = document.createElement("div");
    row.className = "weather-day";

    const icon = document.createElement("img");
    icon.className = "weather-icon";
    icon.src = getWeatherIcon(daily.weathercode[i]);
    icon.alt = getWeatherDescription(daily.weathercode[i]);

    const dayName = document.createElement("div");
    dayName.className = "weather-name";
    dayName.textContent = date.toLocaleDateString(undefined, {
      weekday: "short",
      month: "short",
      day: "numeric",
    });

    const temp = document.createElement("div");
    temp.className = "weather-temp";
    const high = Math.round(daily.temperature_2m_max[i]);
    const low = Math.round(daily.temperature_2m_min[i]);
    temp.textContent = `${high}° / ${low}°`;

    const desc = document.createElement("div");
    desc.className = "weather-desc";
    desc.textContent = getWeatherDescription(daily.weathercode[i]);

    row.appendChild(icon);
    row.appendChild(dayName);
    row.appendChild(temp);
    row.appendChild(desc);
    forecastEl.appendChild(row);
    
    displayed++;
  }
}

function getWeatherIcon(code) {
  if (code === 0) return "icons/clear.png";
  if ([1, 2, 3].includes(code)) return "icons/partly-cloudy.png";
  if ([45, 48].includes(code)) return "icons/fog.png";
  if ([51, 53, 55, 56, 57].includes(code)) return "icons/drizzle.png";
  if ([61, 63, 65, 80, 81, 82].includes(code)) return "icons/rain.png";
  if ([71, 73, 75, 77, 85, 86].includes(code)) return "icons/snow.png";
  if ([95, 96, 99].includes(code)) return "icons/storm.png";
  return "icons/unknown.png";
}

function getWeatherDescription(code) {
  if (code === 0) return "Clear";
  if ([1, 2, 3].includes(code)) return "Cloudy";
  if ([45, 48].includes(code)) return "Fog";
  if ([51, 53, 55, 56, 57].includes(code)) return "Drizzle";
  if ([61, 63, 65, 80, 81, 82].includes(code)) return "Rain";
  if ([71, 73, 75, 77, 85, 86].includes(code)) return "Snow";
  if ([95, 96, 99].includes(code)) return "Storm";
  return "N/A";
}

// ===== TRADINGVIEW WIDGET (CUSTOM FOR SMALLER SIZE) =====
function initTradingViewWidget() {
  const container = document.getElementById('tradingview-widget');
  if (!container || !window.TradingView) return;
  
  // Clear previous content
  container.innerHTML = '';
  
  // Create a minimal chart widget with smaller branding
  new TradingView.widget({
    "container_id": "tradingview-widget",
    "width": "100%",
    "height": "100%",
    "symbol": "AMEX:SPY",
    "interval": "D",
    "timezone": "Etc/UTC",
    "theme": "dark",
    "style": "1",
    "locale": "en",
    "toolbar_bg": "#1a1a1a",
    "enable_publishing": false,
    "allow_symbol_change": false,
    "hide_side_toolbar": false,
    "hideideas": true,
    "studies": [],
    "show_popup_button": false,
    "popup_width": "1000",
    "popup_height": "650",
    // Reduced branding options
    "withdateranges": false,
    "hide_volume": false,
    "hide_top_toolbar": false,
    "save_image": false,
    "calendar": false,
    "news": [],
    "details": false,
    "hotlist": false,
    "watchlist": false
  });
  
  // Additional CSS to reduce branding size
  const style = document.createElement('style');
  style.textContent = `
    #tradingview-widget .tradingview-widget-copyright {
      font-size: 9px !important;
      opacity: 0.7 !important;
    }
    #tradingview-widget .tradingview-widget-container iframe {
      border: none !important;
    }
    #tradingview-widget .logo {
      transform: scale(0.8) !important;
    }
  `;
  document.head.appendChild(style);
}

// ===== INITIALIZATION =====
window.addEventListener('load', () => {
  console.log("Page loaded, initializing...");
  
  loadWeather();
  setInterval(loadWeather, 60 * 60 * 1000);
  
  const savedEvents = localStorage.getItem('calendarEvents');
  const lastUpdated = localStorage.getItem('eventsLastUpdated');
  
  if (savedEvents && lastUpdated && (Date.now() - lastUpdated < 60 * 60 * 1000)) {
    const events = JSON.parse(savedEvents);
    renderEvents(events);
    
    checkVoiceEnabledForToday();
    
    const voiceBtn = document.getElementById("enable-voice");
    voiceBtn.onclick = () => {
      scheduleVoiceReminders(events);
    };
    
    if (voiceEnabled) {
      scheduleVoiceReminders(events);
    }
  }
  
  // Initialize TradingView when library loads
  if (window.TradingView) {
    initTradingViewWidget();
  } else {
    // Wait for TradingView to load
    const checkTradingView = setInterval(() => {
      if (window.TradingView) {
        clearInterval(checkTradingView);
        initTradingViewWidget();
      }
    }, 100);
  }
  
  initGoogleApi();
});

// ===== CLEANUP =====
function cleanupOldReminders() {
  const now = Date.now();
  spokenEvents.clear();
  
  const today = new Date().toDateString();
  if (voiceEnabledDate && voiceEnabledDate !== today) {
    voiceEnabled = false;
    voiceEnabledDate = null;
    localStorage.removeItem('voiceEnabledDate');
    document.getElementById("enable-voice").style.display = "inline-block";
    document.getElementById("enable-voice").textContent = "Enable voice alerts";
    console.log("Voice alerts reset for new day");
  }
  
  const lastUpdated = localStorage.getItem('eventsLastUpdated');
  if (lastUpdated && (now - lastUpdated > 24 * 60 * 60 * 1000)) {
    localStorage.removeItem('calendarEvents');
    localStorage.removeItem('eventsLastUpdated');
  }
}

setInterval(cleanupOldReminders, 60 * 60 * 1000);
</script>
</body>
</html>
